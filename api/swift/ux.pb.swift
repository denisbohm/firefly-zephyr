// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ux.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Firefly_Ux_V1_Completed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_Point {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Int32 = 0

  var y: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_Area {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Int32 = 0

  var y: Int32 = 0

  var width: Int32 = 0

  var height: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_ColorFrameBuffer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var r: UInt32 = 0

  var g: UInt32 = 0

  var b: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_GrayFrameBuffer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var depth: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_GetDisplayMetadataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userInterfaceIdentifier: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_GetDisplayMetadataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: UInt32 = 0

  var height: UInt32 = 0

  var frameBuffer: Firefly_Ux_V1_GetDisplayMetadataResponse.OneOf_FrameBuffer? = nil

  var color: Firefly_Ux_V1_ColorFrameBuffer {
    get {
      if case .color(let v)? = frameBuffer {return v}
      return Firefly_Ux_V1_ColorFrameBuffer()
    }
    set {frameBuffer = .color(newValue)}
  }

  var gray: Firefly_Ux_V1_GrayFrameBuffer {
    get {
      if case .gray(let v)? = frameBuffer {return v}
      return Firefly_Ux_V1_GrayFrameBuffer()
    }
    set {frameBuffer = .gray(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_FrameBuffer: Equatable {
    case color(Firefly_Ux_V1_ColorFrameBuffer)
    case gray(Firefly_Ux_V1_GrayFrameBuffer)

  #if !swift(>=4.1)
    static func ==(lhs: Firefly_Ux_V1_GetDisplayMetadataResponse.OneOf_FrameBuffer, rhs: Firefly_Ux_V1_GetDisplayMetadataResponse.OneOf_FrameBuffer) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.color, .color): return {
        guard case .color(let l) = lhs, case .color(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gray, .gray): return {
        guard case .gray(let l) = lhs, case .gray(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Firefly_Ux_V1_FrameBufferReadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userInterfaceIdentifier: UInt32 = 0

  var area: Firefly_Ux_V1_Area {
    get {return _area ?? Firefly_Ux_V1_Area()}
    set {_area = newValue}
  }
  /// Returns true if `area` has been explicitly set.
  var hasArea: Bool {return self._area != nil}
  /// Clears the value of `area`. Subsequent reads from it will return its default value.
  mutating func clearArea() {self._area = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _area: Firefly_Ux_V1_Area? = nil
}

struct Firefly_Ux_V1_FrameBufferRead {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_FrameBufferReadResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: Firefly_Ux_V1_FrameBufferReadResponse.OneOf_Message? = nil

  var read: Firefly_Ux_V1_FrameBufferRead {
    get {
      if case .read(let v)? = message {return v}
      return Firefly_Ux_V1_FrameBufferRead()
    }
    set {message = .read(newValue)}
  }

  var completed: Firefly_Ux_V1_Completed {
    get {
      if case .completed(let v)? = message {return v}
      return Firefly_Ux_V1_Completed()
    }
    set {message = .completed(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable {
    case read(Firefly_Ux_V1_FrameBufferRead)
    case completed(Firefly_Ux_V1_Completed)

  #if !swift(>=4.1)
    static func ==(lhs: Firefly_Ux_V1_FrameBufferReadResponse.OneOf_Message, rhs: Firefly_Ux_V1_FrameBufferReadResponse.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.read, .read): return {
        guard case .read(let l) = lhs, case .read(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.completed, .completed): return {
        guard case .completed(let l) = lhs, case .completed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Firefly_Ux_V1_GetScreenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userInterfaceIdentifier: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_GetScreenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var screenIdentifier: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_SetScreenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userInterfaceIdentifier: UInt32 = 0

  var screenIdentifier: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_SetScreenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_ButtonEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// none: 0, click: 5
  var gesture: UInt32 = 0

  /// release: 0, pressed: 1
  var action: UInt32 = 0

  var button: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_TouchEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// none: 0, slide up: 1, slide down: 2, slide left: 3, slide right: 4, click: 5, double click: 11, press: 12
  var gesture: UInt32 = 0

  /// release: 0, pressed: 1
  var action: UInt32 = 0

  var x: Int32 = 0

  var y: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_InputEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var delay: Float = 0

  var event: Firefly_Ux_V1_InputEvent.OneOf_Event? = nil

  var buttonEvent: Firefly_Ux_V1_ButtonEvent {
    get {
      if case .buttonEvent(let v)? = event {return v}
      return Firefly_Ux_V1_ButtonEvent()
    }
    set {event = .buttonEvent(newValue)}
  }

  var touchEvent: Firefly_Ux_V1_TouchEvent {
    get {
      if case .touchEvent(let v)? = event {return v}
      return Firefly_Ux_V1_TouchEvent()
    }
    set {event = .touchEvent(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable {
    case buttonEvent(Firefly_Ux_V1_ButtonEvent)
    case touchEvent(Firefly_Ux_V1_TouchEvent)

  #if !swift(>=4.1)
    static func ==(lhs: Firefly_Ux_V1_InputEvent.OneOf_Event, rhs: Firefly_Ux_V1_InputEvent.OneOf_Event) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.buttonEvent, .buttonEvent): return {
        guard case .buttonEvent(let l) = lhs, case .buttonEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.touchEvent, .touchEvent): return {
        guard case .touchEvent(let l) = lhs, case .touchEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Firefly_Ux_V1_SendInputEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userInterfaceIdentifier: UInt32 = 0

  var inputEvents: [Firefly_Ux_V1_InputEvent] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_SendInputEventsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_UpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userInterfaceIdentifier: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_UpdateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_SetUpdateEnabledRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userInterfaceIdentifier: UInt32 = 0

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_SetUpdateEnabledResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_GetUpdateEnabledRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userInterfaceIdentifier: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_GetUpdateEnabledResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_DisplayConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timeout: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_SetDisplayConfigurationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userInterfaceIdentifier: UInt32 = 0

  var configuration: Firefly_Ux_V1_DisplayConfiguration {
    get {return _configuration ?? Firefly_Ux_V1_DisplayConfiguration()}
    set {_configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  var hasConfiguration: Bool {return self._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  mutating func clearConfiguration() {self._configuration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _configuration: Firefly_Ux_V1_DisplayConfiguration? = nil
}

struct Firefly_Ux_V1_SetDisplayConfigurationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_GetDisplayConfigurationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userInterfaceIdentifier: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_GetDisplayConfigurationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var configuration: Firefly_Ux_V1_DisplayConfiguration {
    get {return _configuration ?? Firefly_Ux_V1_DisplayConfiguration()}
    set {_configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  var hasConfiguration: Bool {return self._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  mutating func clearConfiguration() {self._configuration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _configuration: Firefly_Ux_V1_DisplayConfiguration? = nil
}

struct Firefly_Ux_V1_NavigateOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var screenIdentifier: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_FunctionOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var functionIdentifier: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_ButtonCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gesture: UInt32 = 0

  var button: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_TouchCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gesture: UInt32 = 0

  var area: Firefly_Ux_V1_Area {
    get {return _area ?? Firefly_Ux_V1_Area()}
    set {_area = newValue}
  }
  /// Returns true if `area` has been explicitly set.
  var hasArea: Bool {return self._area != nil}
  /// Clears the value of `area`. Subsequent reads from it will return its default value.
  mutating func clearArea() {self._area = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _area: Firefly_Ux_V1_Area? = nil
}

struct Firefly_Ux_V1_EventInteractionConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var condition: Firefly_Ux_V1_EventInteractionConfiguration.OneOf_Condition? = nil

  var buttonCondition: Firefly_Ux_V1_ButtonCondition {
    get {
      if case .buttonCondition(let v)? = condition {return v}
      return Firefly_Ux_V1_ButtonCondition()
    }
    set {condition = .buttonCondition(newValue)}
  }

  var touchCondition: Firefly_Ux_V1_TouchCondition {
    get {
      if case .touchCondition(let v)? = condition {return v}
      return Firefly_Ux_V1_TouchCondition()
    }
    set {condition = .touchCondition(newValue)}
  }

  var operation: Firefly_Ux_V1_EventInteractionConfiguration.OneOf_Operation? = nil

  var navigateOperation: Firefly_Ux_V1_NavigateOperation {
    get {
      if case .navigateOperation(let v)? = operation {return v}
      return Firefly_Ux_V1_NavigateOperation()
    }
    set {operation = .navigateOperation(newValue)}
  }

  var functionOperation: Firefly_Ux_V1_FunctionOperation {
    get {
      if case .functionOperation(let v)? = operation {return v}
      return Firefly_Ux_V1_FunctionOperation()
    }
    set {operation = .functionOperation(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Condition: Equatable {
    case buttonCondition(Firefly_Ux_V1_ButtonCondition)
    case touchCondition(Firefly_Ux_V1_TouchCondition)

  #if !swift(>=4.1)
    static func ==(lhs: Firefly_Ux_V1_EventInteractionConfiguration.OneOf_Condition, rhs: Firefly_Ux_V1_EventInteractionConfiguration.OneOf_Condition) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.buttonCondition, .buttonCondition): return {
        guard case .buttonCondition(let l) = lhs, case .buttonCondition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.touchCondition, .touchCondition): return {
        guard case .touchCondition(let l) = lhs, case .touchCondition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum OneOf_Operation: Equatable {
    case navigateOperation(Firefly_Ux_V1_NavigateOperation)
    case functionOperation(Firefly_Ux_V1_FunctionOperation)

  #if !swift(>=4.1)
    static func ==(lhs: Firefly_Ux_V1_EventInteractionConfiguration.OneOf_Operation, rhs: Firefly_Ux_V1_EventInteractionConfiguration.OneOf_Operation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.navigateOperation, .navigateOperation): return {
        guard case .navigateOperation(let l) = lhs, case .navigateOperation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.functionOperation, .functionOperation): return {
        guard case .functionOperation(let l) = lhs, case .functionOperation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Firefly_Ux_V1_ScreenInteractionConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var screenIdentifier: UInt32 = 0

  var eventInteractionConfigurations: [Firefly_Ux_V1_EventInteractionConfiguration] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_InteractionConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var screenInteractionConfigurations: [Firefly_Ux_V1_ScreenInteractionConfiguration] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_GetInteractionConfigurationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userInterfaceIdentifier: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Firefly_Ux_V1_GetInteractionConfigurationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var configuration: Firefly_Ux_V1_InteractionConfiguration {
    get {return _configuration ?? Firefly_Ux_V1_InteractionConfiguration()}
    set {_configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  var hasConfiguration: Bool {return self._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  mutating func clearConfiguration() {self._configuration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _configuration: Firefly_Ux_V1_InteractionConfiguration? = nil
}

struct Firefly_Ux_V1_SetInteractionConfigurationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userInterfaceIdentifier: UInt32 = 0

  var configuration: Firefly_Ux_V1_InteractionConfiguration {
    get {return _configuration ?? Firefly_Ux_V1_InteractionConfiguration()}
    set {_configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  var hasConfiguration: Bool {return self._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  mutating func clearConfiguration() {self._configuration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _configuration: Firefly_Ux_V1_InteractionConfiguration? = nil
}

struct Firefly_Ux_V1_SetInteractionConfigurationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Firefly_Ux_V1_Completed: @unchecked Sendable {}
extension Firefly_Ux_V1_Point: @unchecked Sendable {}
extension Firefly_Ux_V1_Area: @unchecked Sendable {}
extension Firefly_Ux_V1_ColorFrameBuffer: @unchecked Sendable {}
extension Firefly_Ux_V1_GrayFrameBuffer: @unchecked Sendable {}
extension Firefly_Ux_V1_GetDisplayMetadataRequest: @unchecked Sendable {}
extension Firefly_Ux_V1_GetDisplayMetadataResponse: @unchecked Sendable {}
extension Firefly_Ux_V1_GetDisplayMetadataResponse.OneOf_FrameBuffer: @unchecked Sendable {}
extension Firefly_Ux_V1_FrameBufferReadRequest: @unchecked Sendable {}
extension Firefly_Ux_V1_FrameBufferRead: @unchecked Sendable {}
extension Firefly_Ux_V1_FrameBufferReadResponse: @unchecked Sendable {}
extension Firefly_Ux_V1_FrameBufferReadResponse.OneOf_Message: @unchecked Sendable {}
extension Firefly_Ux_V1_GetScreenRequest: @unchecked Sendable {}
extension Firefly_Ux_V1_GetScreenResponse: @unchecked Sendable {}
extension Firefly_Ux_V1_SetScreenRequest: @unchecked Sendable {}
extension Firefly_Ux_V1_SetScreenResponse: @unchecked Sendable {}
extension Firefly_Ux_V1_ButtonEvent: @unchecked Sendable {}
extension Firefly_Ux_V1_TouchEvent: @unchecked Sendable {}
extension Firefly_Ux_V1_InputEvent: @unchecked Sendable {}
extension Firefly_Ux_V1_InputEvent.OneOf_Event: @unchecked Sendable {}
extension Firefly_Ux_V1_SendInputEventsRequest: @unchecked Sendable {}
extension Firefly_Ux_V1_SendInputEventsResponse: @unchecked Sendable {}
extension Firefly_Ux_V1_UpdateRequest: @unchecked Sendable {}
extension Firefly_Ux_V1_UpdateResponse: @unchecked Sendable {}
extension Firefly_Ux_V1_SetUpdateEnabledRequest: @unchecked Sendable {}
extension Firefly_Ux_V1_SetUpdateEnabledResponse: @unchecked Sendable {}
extension Firefly_Ux_V1_GetUpdateEnabledRequest: @unchecked Sendable {}
extension Firefly_Ux_V1_GetUpdateEnabledResponse: @unchecked Sendable {}
extension Firefly_Ux_V1_DisplayConfiguration: @unchecked Sendable {}
extension Firefly_Ux_V1_SetDisplayConfigurationRequest: @unchecked Sendable {}
extension Firefly_Ux_V1_SetDisplayConfigurationResponse: @unchecked Sendable {}
extension Firefly_Ux_V1_GetDisplayConfigurationRequest: @unchecked Sendable {}
extension Firefly_Ux_V1_GetDisplayConfigurationResponse: @unchecked Sendable {}
extension Firefly_Ux_V1_NavigateOperation: @unchecked Sendable {}
extension Firefly_Ux_V1_FunctionOperation: @unchecked Sendable {}
extension Firefly_Ux_V1_ButtonCondition: @unchecked Sendable {}
extension Firefly_Ux_V1_TouchCondition: @unchecked Sendable {}
extension Firefly_Ux_V1_EventInteractionConfiguration: @unchecked Sendable {}
extension Firefly_Ux_V1_EventInteractionConfiguration.OneOf_Condition: @unchecked Sendable {}
extension Firefly_Ux_V1_EventInteractionConfiguration.OneOf_Operation: @unchecked Sendable {}
extension Firefly_Ux_V1_ScreenInteractionConfiguration: @unchecked Sendable {}
extension Firefly_Ux_V1_InteractionConfiguration: @unchecked Sendable {}
extension Firefly_Ux_V1_GetInteractionConfigurationRequest: @unchecked Sendable {}
extension Firefly_Ux_V1_GetInteractionConfigurationResponse: @unchecked Sendable {}
extension Firefly_Ux_V1_SetInteractionConfigurationRequest: @unchecked Sendable {}
extension Firefly_Ux_V1_SetInteractionConfigurationResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "firefly.ux.v1"

extension Firefly_Ux_V1_Completed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Completed"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_Completed, rhs: Firefly_Ux_V1_Completed) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_Point: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Point"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularSInt32Field(value: &self.x) }()
      case 2: try { try decoder.decodeSingularSInt32Field(value: &self.y) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularSInt32Field(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularSInt32Field(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_Point, rhs: Firefly_Ux_V1_Point) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_Area: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Area"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "width"),
    4: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularSInt32Field(value: &self.x) }()
      case 2: try { try decoder.decodeSingularSInt32Field(value: &self.y) }()
      case 3: try { try decoder.decodeSingularSInt32Field(value: &self.width) }()
      case 4: try { try decoder.decodeSingularSInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularSInt32Field(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularSInt32Field(value: self.y, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularSInt32Field(value: self.width, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularSInt32Field(value: self.height, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_Area, rhs: Firefly_Ux_V1_Area) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_ColorFrameBuffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ColorFrameBuffer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "r"),
    2: .same(proto: "g"),
    3: .same(proto: "b"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.r) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.g) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.b) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.r != 0 {
      try visitor.visitSingularUInt32Field(value: self.r, fieldNumber: 1)
    }
    if self.g != 0 {
      try visitor.visitSingularUInt32Field(value: self.g, fieldNumber: 2)
    }
    if self.b != 0 {
      try visitor.visitSingularUInt32Field(value: self.b, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_ColorFrameBuffer, rhs: Firefly_Ux_V1_ColorFrameBuffer) -> Bool {
    if lhs.r != rhs.r {return false}
    if lhs.g != rhs.g {return false}
    if lhs.b != rhs.b {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_GrayFrameBuffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GrayFrameBuffer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "depth"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.depth) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.depth != 0 {
      try visitor.visitSingularUInt32Field(value: self.depth, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_GrayFrameBuffer, rhs: Firefly_Ux_V1_GrayFrameBuffer) -> Bool {
    if lhs.depth != rhs.depth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_GetDisplayMetadataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDisplayMetadataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_interface_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.userInterfaceIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userInterfaceIdentifier != 0 {
      try visitor.visitSingularUInt32Field(value: self.userInterfaceIdentifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_GetDisplayMetadataRequest, rhs: Firefly_Ux_V1_GetDisplayMetadataRequest) -> Bool {
    if lhs.userInterfaceIdentifier != rhs.userInterfaceIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_GetDisplayMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDisplayMetadataResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "color"),
    4: .same(proto: "gray"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 3: try {
        var v: Firefly_Ux_V1_ColorFrameBuffer?
        var hadOneofValue = false
        if let current = self.frameBuffer {
          hadOneofValue = true
          if case .color(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.frameBuffer = .color(v)
        }
      }()
      case 4: try {
        var v: Firefly_Ux_V1_GrayFrameBuffer?
        var hadOneofValue = false
        if let current = self.frameBuffer {
          hadOneofValue = true
          if case .gray(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.frameBuffer = .gray(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 2)
    }
    switch self.frameBuffer {
    case .color?: try {
      guard case .color(let v)? = self.frameBuffer else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .gray?: try {
      guard case .gray(let v)? = self.frameBuffer else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_GetDisplayMetadataResponse, rhs: Firefly_Ux_V1_GetDisplayMetadataResponse) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.frameBuffer != rhs.frameBuffer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_FrameBufferReadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FrameBufferReadRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_interface_identifier"),
    2: .same(proto: "area"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.userInterfaceIdentifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._area) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.userInterfaceIdentifier != 0 {
      try visitor.visitSingularUInt32Field(value: self.userInterfaceIdentifier, fieldNumber: 1)
    }
    try { if let v = self._area {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_FrameBufferReadRequest, rhs: Firefly_Ux_V1_FrameBufferReadRequest) -> Bool {
    if lhs.userInterfaceIdentifier != rhs.userInterfaceIdentifier {return false}
    if lhs._area != rhs._area {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_FrameBufferRead: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FrameBufferRead"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_FrameBufferRead, rhs: Firefly_Ux_V1_FrameBufferRead) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_FrameBufferReadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FrameBufferReadResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "read"),
    2: .same(proto: "completed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Firefly_Ux_V1_FrameBufferRead?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .read(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .read(v)
        }
      }()
      case 2: try {
        var v: Firefly_Ux_V1_Completed?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .completed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .completed(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .read?: try {
      guard case .read(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .completed?: try {
      guard case .completed(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_FrameBufferReadResponse, rhs: Firefly_Ux_V1_FrameBufferReadResponse) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_GetScreenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetScreenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_interface_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.userInterfaceIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userInterfaceIdentifier != 0 {
      try visitor.visitSingularUInt32Field(value: self.userInterfaceIdentifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_GetScreenRequest, rhs: Firefly_Ux_V1_GetScreenRequest) -> Bool {
    if lhs.userInterfaceIdentifier != rhs.userInterfaceIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_GetScreenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetScreenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "screen_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.screenIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.screenIdentifier != 0 {
      try visitor.visitSingularUInt32Field(value: self.screenIdentifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_GetScreenResponse, rhs: Firefly_Ux_V1_GetScreenResponse) -> Bool {
    if lhs.screenIdentifier != rhs.screenIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_SetScreenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetScreenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_interface_identifier"),
    2: .standard(proto: "screen_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.userInterfaceIdentifier) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.screenIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userInterfaceIdentifier != 0 {
      try visitor.visitSingularUInt32Field(value: self.userInterfaceIdentifier, fieldNumber: 1)
    }
    if self.screenIdentifier != 0 {
      try visitor.visitSingularUInt32Field(value: self.screenIdentifier, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_SetScreenRequest, rhs: Firefly_Ux_V1_SetScreenRequest) -> Bool {
    if lhs.userInterfaceIdentifier != rhs.userInterfaceIdentifier {return false}
    if lhs.screenIdentifier != rhs.screenIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_SetScreenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetScreenResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_SetScreenResponse, rhs: Firefly_Ux_V1_SetScreenResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_ButtonEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ButtonEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gesture"),
    2: .same(proto: "action"),
    3: .same(proto: "button"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.gesture) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.action) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.button) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gesture != 0 {
      try visitor.visitSingularUInt32Field(value: self.gesture, fieldNumber: 1)
    }
    if self.action != 0 {
      try visitor.visitSingularUInt32Field(value: self.action, fieldNumber: 2)
    }
    if self.button != 0 {
      try visitor.visitSingularUInt32Field(value: self.button, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_ButtonEvent, rhs: Firefly_Ux_V1_ButtonEvent) -> Bool {
    if lhs.gesture != rhs.gesture {return false}
    if lhs.action != rhs.action {return false}
    if lhs.button != rhs.button {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_TouchEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TouchEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gesture"),
    2: .same(proto: "action"),
    3: .same(proto: "x"),
    4: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.gesture) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.action) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.x) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.y) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gesture != 0 {
      try visitor.visitSingularUInt32Field(value: self.gesture, fieldNumber: 1)
    }
    if self.action != 0 {
      try visitor.visitSingularUInt32Field(value: self.action, fieldNumber: 2)
    }
    if self.x != 0 {
      try visitor.visitSingularInt32Field(value: self.x, fieldNumber: 3)
    }
    if self.y != 0 {
      try visitor.visitSingularInt32Field(value: self.y, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_TouchEvent, rhs: Firefly_Ux_V1_TouchEvent) -> Bool {
    if lhs.gesture != rhs.gesture {return false}
    if lhs.action != rhs.action {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_InputEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InputEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delay"),
    2: .standard(proto: "button_event"),
    3: .standard(proto: "touch_event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.delay) }()
      case 2: try {
        var v: Firefly_Ux_V1_ButtonEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .buttonEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .buttonEvent(v)
        }
      }()
      case 3: try {
        var v: Firefly_Ux_V1_TouchEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .touchEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .touchEvent(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.delay != 0 {
      try visitor.visitSingularFloatField(value: self.delay, fieldNumber: 1)
    }
    switch self.event {
    case .buttonEvent?: try {
      guard case .buttonEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .touchEvent?: try {
      guard case .touchEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_InputEvent, rhs: Firefly_Ux_V1_InputEvent) -> Bool {
    if lhs.delay != rhs.delay {return false}
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_SendInputEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendInputEventsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_interface_identifier"),
    2: .standard(proto: "input_events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.userInterfaceIdentifier) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.inputEvents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userInterfaceIdentifier != 0 {
      try visitor.visitSingularUInt32Field(value: self.userInterfaceIdentifier, fieldNumber: 1)
    }
    if !self.inputEvents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputEvents, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_SendInputEventsRequest, rhs: Firefly_Ux_V1_SendInputEventsRequest) -> Bool {
    if lhs.userInterfaceIdentifier != rhs.userInterfaceIdentifier {return false}
    if lhs.inputEvents != rhs.inputEvents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_SendInputEventsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendInputEventsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_SendInputEventsResponse, rhs: Firefly_Ux_V1_SendInputEventsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_UpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_interface_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.userInterfaceIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userInterfaceIdentifier != 0 {
      try visitor.visitSingularUInt32Field(value: self.userInterfaceIdentifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_UpdateRequest, rhs: Firefly_Ux_V1_UpdateRequest) -> Bool {
    if lhs.userInterfaceIdentifier != rhs.userInterfaceIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_UpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_UpdateResponse, rhs: Firefly_Ux_V1_UpdateResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_SetUpdateEnabledRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetUpdateEnabledRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_interface_identifier"),
    2: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.userInterfaceIdentifier) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userInterfaceIdentifier != 0 {
      try visitor.visitSingularUInt32Field(value: self.userInterfaceIdentifier, fieldNumber: 1)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_SetUpdateEnabledRequest, rhs: Firefly_Ux_V1_SetUpdateEnabledRequest) -> Bool {
    if lhs.userInterfaceIdentifier != rhs.userInterfaceIdentifier {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_SetUpdateEnabledResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetUpdateEnabledResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_SetUpdateEnabledResponse, rhs: Firefly_Ux_V1_SetUpdateEnabledResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_GetUpdateEnabledRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUpdateEnabledRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_interface_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.userInterfaceIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userInterfaceIdentifier != 0 {
      try visitor.visitSingularUInt32Field(value: self.userInterfaceIdentifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_GetUpdateEnabledRequest, rhs: Firefly_Ux_V1_GetUpdateEnabledRequest) -> Bool {
    if lhs.userInterfaceIdentifier != rhs.userInterfaceIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_GetUpdateEnabledResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUpdateEnabledResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_GetUpdateEnabledResponse, rhs: Firefly_Ux_V1_GetUpdateEnabledResponse) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_DisplayConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timeout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.timeout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeout != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeout, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_DisplayConfiguration, rhs: Firefly_Ux_V1_DisplayConfiguration) -> Bool {
    if lhs.timeout != rhs.timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_SetDisplayConfigurationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetDisplayConfigurationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_interface_identifier"),
    2: .same(proto: "configuration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.userInterfaceIdentifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.userInterfaceIdentifier != 0 {
      try visitor.visitSingularUInt32Field(value: self.userInterfaceIdentifier, fieldNumber: 1)
    }
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_SetDisplayConfigurationRequest, rhs: Firefly_Ux_V1_SetDisplayConfigurationRequest) -> Bool {
    if lhs.userInterfaceIdentifier != rhs.userInterfaceIdentifier {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_SetDisplayConfigurationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetDisplayConfigurationResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_SetDisplayConfigurationResponse, rhs: Firefly_Ux_V1_SetDisplayConfigurationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_GetDisplayConfigurationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDisplayConfigurationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_interface_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.userInterfaceIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userInterfaceIdentifier != 0 {
      try visitor.visitSingularUInt32Field(value: self.userInterfaceIdentifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_GetDisplayConfigurationRequest, rhs: Firefly_Ux_V1_GetDisplayConfigurationRequest) -> Bool {
    if lhs.userInterfaceIdentifier != rhs.userInterfaceIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_GetDisplayConfigurationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDisplayConfigurationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "configuration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_GetDisplayConfigurationResponse, rhs: Firefly_Ux_V1_GetDisplayConfigurationResponse) -> Bool {
    if lhs._configuration != rhs._configuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_NavigateOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NavigateOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "screen_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.screenIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.screenIdentifier != 0 {
      try visitor.visitSingularUInt32Field(value: self.screenIdentifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_NavigateOperation, rhs: Firefly_Ux_V1_NavigateOperation) -> Bool {
    if lhs.screenIdentifier != rhs.screenIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_FunctionOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FunctionOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "function_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.functionIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.functionIdentifier != 0 {
      try visitor.visitSingularUInt32Field(value: self.functionIdentifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_FunctionOperation, rhs: Firefly_Ux_V1_FunctionOperation) -> Bool {
    if lhs.functionIdentifier != rhs.functionIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_ButtonCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ButtonCondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gesture"),
    2: .same(proto: "button"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.gesture) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.button) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gesture != 0 {
      try visitor.visitSingularUInt32Field(value: self.gesture, fieldNumber: 1)
    }
    if self.button != 0 {
      try visitor.visitSingularUInt32Field(value: self.button, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_ButtonCondition, rhs: Firefly_Ux_V1_ButtonCondition) -> Bool {
    if lhs.gesture != rhs.gesture {return false}
    if lhs.button != rhs.button {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_TouchCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TouchCondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gesture"),
    2: .same(proto: "area"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.gesture) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._area) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.gesture != 0 {
      try visitor.visitSingularUInt32Field(value: self.gesture, fieldNumber: 1)
    }
    try { if let v = self._area {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_TouchCondition, rhs: Firefly_Ux_V1_TouchCondition) -> Bool {
    if lhs.gesture != rhs.gesture {return false}
    if lhs._area != rhs._area {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_EventInteractionConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventInteractionConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "button_condition"),
    2: .standard(proto: "touch_condition"),
    3: .standard(proto: "navigate_operation"),
    4: .standard(proto: "function_operation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Firefly_Ux_V1_ButtonCondition?
        var hadOneofValue = false
        if let current = self.condition {
          hadOneofValue = true
          if case .buttonCondition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.condition = .buttonCondition(v)
        }
      }()
      case 2: try {
        var v: Firefly_Ux_V1_TouchCondition?
        var hadOneofValue = false
        if let current = self.condition {
          hadOneofValue = true
          if case .touchCondition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.condition = .touchCondition(v)
        }
      }()
      case 3: try {
        var v: Firefly_Ux_V1_NavigateOperation?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .navigateOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .navigateOperation(v)
        }
      }()
      case 4: try {
        var v: Firefly_Ux_V1_FunctionOperation?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .functionOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .functionOperation(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.condition {
    case .buttonCondition?: try {
      guard case .buttonCondition(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .touchCondition?: try {
      guard case .touchCondition(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    switch self.operation {
    case .navigateOperation?: try {
      guard case .navigateOperation(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .functionOperation?: try {
      guard case .functionOperation(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_EventInteractionConfiguration, rhs: Firefly_Ux_V1_EventInteractionConfiguration) -> Bool {
    if lhs.condition != rhs.condition {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_ScreenInteractionConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScreenInteractionConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "screen_identifier"),
    2: .standard(proto: "event_interaction_configurations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.screenIdentifier) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.eventInteractionConfigurations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.screenIdentifier != 0 {
      try visitor.visitSingularUInt32Field(value: self.screenIdentifier, fieldNumber: 1)
    }
    if !self.eventInteractionConfigurations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.eventInteractionConfigurations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_ScreenInteractionConfiguration, rhs: Firefly_Ux_V1_ScreenInteractionConfiguration) -> Bool {
    if lhs.screenIdentifier != rhs.screenIdentifier {return false}
    if lhs.eventInteractionConfigurations != rhs.eventInteractionConfigurations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_InteractionConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InteractionConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "screen_interaction_configurations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.screenInteractionConfigurations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.screenInteractionConfigurations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.screenInteractionConfigurations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_InteractionConfiguration, rhs: Firefly_Ux_V1_InteractionConfiguration) -> Bool {
    if lhs.screenInteractionConfigurations != rhs.screenInteractionConfigurations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_GetInteractionConfigurationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInteractionConfigurationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_interface_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.userInterfaceIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userInterfaceIdentifier != 0 {
      try visitor.visitSingularUInt32Field(value: self.userInterfaceIdentifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_GetInteractionConfigurationRequest, rhs: Firefly_Ux_V1_GetInteractionConfigurationRequest) -> Bool {
    if lhs.userInterfaceIdentifier != rhs.userInterfaceIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_GetInteractionConfigurationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInteractionConfigurationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "configuration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_GetInteractionConfigurationResponse, rhs: Firefly_Ux_V1_GetInteractionConfigurationResponse) -> Bool {
    if lhs._configuration != rhs._configuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_SetInteractionConfigurationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetInteractionConfigurationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_interface_identifier"),
    2: .same(proto: "configuration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.userInterfaceIdentifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.userInterfaceIdentifier != 0 {
      try visitor.visitSingularUInt32Field(value: self.userInterfaceIdentifier, fieldNumber: 1)
    }
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_SetInteractionConfigurationRequest, rhs: Firefly_Ux_V1_SetInteractionConfigurationRequest) -> Bool {
    if lhs.userInterfaceIdentifier != rhs.userInterfaceIdentifier {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Firefly_Ux_V1_SetInteractionConfigurationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetInteractionConfigurationResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Firefly_Ux_V1_SetInteractionConfigurationResponse, rhs: Firefly_Ux_V1_SetInteractionConfigurationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
